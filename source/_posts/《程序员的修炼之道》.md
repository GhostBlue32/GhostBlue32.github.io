---
title: '[[《程序员的修炼之道》]]'
date: '2025-08-20'
tags:
- David
---
#David·Tomas

不要放任破窗：对于软件之中“糟糕的设计、错误的决定、低劣的代码”，每发现一个就去修理一个。否则很容易就会滑坡，是团队衰败的开始，很容易就会造成团队成员认为反正已经这样了，不如破罐子破摔。即便是有截止日期等事情，也不要想着弄乱它。

“永远留意着大局，持续不断地审视你身边发生的事情，而不要只专注于你个人在做的事情。”

面对筹备期的劳累，只要有成果产出，就给大家看，然后用“加上一点什么就可以更好”。只要能够窥探到未来，大家就能更好地团结在一起。

对知识组合做定期投资：
1. 每年学习一门新语言。
2. 每个月读一本技术书。
3. 还要读一些非技术书。
4. 上课：本地的大学或者网上找，或许能在下一场商业会展或技术会议上找到。
5. 加入本地的用户组和交流群。
6. 尝试不同的环境

你是否在项目中使用过这些技术并不重要，甚至要不要把它们放在你的简历中也不重要。学习的过程将会扩展你的思维，为你打开全新可能性的大门，让你领悟新的做事方式。想法的交叉传授是很重要的。

### 务实的方法
优秀设计的精髓：ETC（Easier To Change） 原则：更容易变更。

DRY：在一个系统中，每一处知识都必须单一、明确、权威地表达：
1. 浅层含义：不要粘贴源码。
2. 针对对于知识和意图的复制，强调的是在两个地方表达的东西其实是相通的，只是表达方式有可能完全不同。
3. 并非所有代码重复都是知识的重复，可能是表达了两个不同的东西却恰好使用了相同的规则。
4. 在开发的过程之中，可能因为需要缓存数据而违背 DRY 原则，解决办法是将负面影响控制在局部。一个模块提供的所有服务都应该通过统一的约定来提供，该约定不应该表露出其内部实现。
5. 表征的重复：
	1. 内部 API：用工具将其描述成一种中立的格式，能生成文档、模拟API、功能测试，之后还可以生成不同语言的 API 客户端。
	2. 外部 API：使用 OPENAPI 等东西做正式的规范，方便导入本地 API 工具，更可靠地和服务集成。
	3. 数据源：许多数据源允许对数据的结构进行内省。还有一个选择是将数据插入键值对的数据结构，不过最好还要增加一张表驱动的校验组件。

正交性：
1. 对于两个或多个事物，其中一个的改变不影响其他任何一个。
2. 数据库相关代码应该和用户界面保持正交。
3. 主要收益：
	1. 获得生产力。开发和测试时间都会减少，并且促进了重复利用。
	2. 减少了开发中内在的风险。
4. 保持正交性的方法：
	1. 模块不向其他模块透露任何不必要的信息，也不依赖于其他模块的实现。
	2. 避免全局数据：引用全局数据，就会将自己绑定到共享该数据的组件上。如果总是显式地将任何需要的上下文传递给模块，那么代码会更容易理解和维护。
	3. 避免相似函数：或许在开头和结尾共享公共代码，但每个函数都有不同的中心算法。养成不断质疑代码的习惯，只要有机会就重新组织、改善其结构和正交性。

可逆性：
1. 不设最终决定。保持代码的灵活性，以及体系结构、部署和供应商集成方面的灵活性。
2. 放弃追逐时尚，让代码顺境中摇摆滚动，逆境时直面困难。

曳光弹：寻找重要的需求，那些定义了系统的需求，寻找有问题的地方，那些你认为有重大风险的地方，然后对开发进行优先级排序，首先从这些地方开始编码。曳光弹作为框架，编写是为了持续使用，只是功能还不完整。

原型：用来分析和暴露风险，以一种能大幅降低成本的方式获得修正的机会。

### 基础工具
纯文本：
1. 由可打印字符组成的，构成某种用来传递信息的形态。
2. 二进制格式的问题：理解数据所需的上下文与数据本身是分离的。
3. 所有的工具都可以对纯文本进行操作。

指令shell：
1. 程序员的工作台。
2. 试玩一下 shell 命令。
3. 常见的变更包括：
	1. 设置颜色主题。
	2. 配置提示信息。
	3. 别名和 shell 函数，对于大量使用的命令组。
	4. 命令补全。

加强编辑能力：编辑时进行自省，对于自己重复做的某件事情，习惯性想到是否有更好的办法。

版本控制：可逆性，可以多人协同在不同分支上工作。思考如果笔记本换一台新的，多久才能恢复到当初的状态。

调试：
1. bug 是谁的错并不重要，最终都是要你来面对
2. 不要陷入恐慌。
3. 不要短视，不仅仅去纠结所看到的症状。永远去发掘问题的根本原因，而不仅仅停留在问题的表面现象。
4. 需要摆放报告 bug 的用户，这样才能收集到更多的数据。人为的测试对应用程序而言还不够，必须粗暴地测试所有边界条件，并且复原实际的最终用户使用模式。
5. 二分法跟踪问题：面对一个大型堆栈跟踪，可以在调用栈中间选一帧来进行切分，看看错误是否在那里出现。
6. 遇到一个意外的 bug 时，除了修复它，还要确定为什么没有更早地发现这个错误，考虑一下，是否需要修改单元测试或其他测试，以便让这些测试能够捕获到它。

学习一门文本处理语言，对于文本进行直接处理、格式化。

### 务实的偏执
无法写出完美的软件。为自己的错误建立防御机制。

契约式设计：
1. 前置条件：调用这个例程，必须为真的是什么？绝不能在违反的时候被调用。测试发生在调用者调用例程之后，进入例程之前。
2. 后置条件：例程保证要做的是什么？完成时世界的状态。
3. 类的不变式：确保该条件始终为真，内部处理期间，可以不遵循不变式，但是推出并将控制权返回给调用者时，不变式必须为真。

尽早崩溃：崩溃通常是能做的最好的事情。将责任交给监管程序。形成由监管程序树构成的设计。

断言式编程：
1. 当自己在想“这是不可能发生的”时，添加代码来检查这一点。
2. 无法假设测试会发现所有 bug，必须加上断言来防止任何可能的错误。

保持资源的平衡
1. 分配资源的函数或对象，对释放资源应该负有责任。
2. 释放资源的顺序与分配资源的顺序相反。
3. 不同位置中，如果都会分配同一组资源，则始终以相同的顺序分配它们。

### 宁弯不折
与其费力为不确定的未来做设计，不如将代码设计成可替换的。

解耦：
1. 不要链式调用方法，除非链式调用的东西真的不太可能改变。第三方库中的任何东西都应该被认为是易变的。
2. 修改全局变量的实现可能会潜在地影响到系统中的所有代码。
3. 如果全局数据唯一非常重要，那么将它包装到 API 中。
4. 让代码害羞一些，让它只处理直接知道的事情，将有助于保持应用程序解耦，使其更容易变更。

抛球游戏：
1. 有限状态机：一个系统在有限个状态之间，根据输入发生转移，并可能产生输出的过程。
2. 观察者模式：观察者根据兴趣被注册到观察对象上。事件发生时，观察对象遍历观察者列表，并调用每个传递给它的函数。每个观察者都必须与观察对象注册在一起。
3. 发布/订阅，通过信道连接在一起的。信道在单独的代码块中实现，所有实现细节隐藏，通信在代码之外处理。无法查看发布者的同时立即看到有哪些订阅者涉及特定的消息。
4. **流**是一种**按顺序到达的数据元素序列**，在时间轴上一个接一个地产生，可以被持续消费。

变换式编程：数据不再和特定函数组一起绑定在类定义中。应用程序将输入转换为输出时，可以自由地表达自己的展开过程。将代码看作一系列的变换。

尽量不使用继承：
1. 接口与协议：由一个类来实现一个或多个行为集。然后在类定义的时候规定这些类必须实现。
2. 委托：在目标之中创建一个持久化对象来做各种操作。
3. mixin：创建一组函数，给这个函数组起一个名字，然后用它去扩展一个类或对象。

配置：如果代码依赖某些值，而这些值在应用程序发布后还有可能改变，那么就把这些值放在程序外部。做法为配置数据保持在程序外部，不直接放在文件之中，储存在一个服务API之后。配置应该是动态的。

### 当你编码时
听从蜥蜴脑：
1. 脑力突破方法：
	1. 在便签上写下，正在做原型，贴在屏幕一侧。
	2. 提醒自己，原型注定要出问题，提醒自己即便原型没有出问题也要被扔掉。
	3. 在空窗口编辑器中，写一条注释，用一句话来描述你想学点什么或做点什么。
	4. 开始编码
2. 当事情以一种奇怪的方式完成时，把它记下来，持续这样做，试着寻找模式。
3. 如果什么让你感到不舒服，停下来分析这种感觉，在问题跳出来前加以避免。

深思熟虑地编程：
1. 不要在黑暗中编码，构建一个没有完全掌握的应用程序，或者使用一个并不理解的技术，就会被巧合咬伤。
2. 只依赖可靠的东西，如果不知道是否可靠，就要做最坏的打算。
3. 假设文档化，将所有假设写下来，同时帮助与他人的沟通。
4. 不让现在的代码去支配未来的代码，随时准备好重构。

重构：
1. 重组现有代码实体，改变其内部结构而不改变其外部行为的规范式技术。
2. 核心是重新设计，要尽早重构，经常重构，只要有新的知识能让此前的代码表现得更好，就要进行重构。
3. 技巧：
	1. 不要试图让重构和添加功能同时进行。
	2. 开始重构前确保有良好的测试，尽可能多地运行测试。
	3. 采用简短而慎重的步骤，保持小步骤，并在每个步骤之后进行测试。

测试：
1. 测试的好处发生在考虑测试以及编写测试的时候，而非在运行测试的时候。这让我们得以从外部、以客户的视角来看待这个方法。
2. 针对契约来进行测试。如果一个模块下面包含了几个组件，那么就先对组件进行契约测试，通过后再对整个模块进行契约测试。
3. 基于特性进行测试：找到现在研究问题的不变量，测试在不同环境之下，这个不变量是否依旧保持不变。

代码安全：
1. 将攻击面最小化。保持简单、对于外部传入数据进行消毒、小心未经认证的服务、注意经过认证的服务的保护力度、输出数据、调试信息。
2. 最小特权原则：在最短的时间内使用最少的特权。
3. 默认值应该是安全的。
4. 敏感数据一定要加密，不要将其放在版本控制之下。通过配置文件或环境变量来管理。
5. 尽早打上安全补丁。
6. 安全的事情非同小可，尽量交给专业的人（第三方公司）来做。

### 并发
并发指两个或更多个代码段在执行过程中表现得像同时运行一样，并行性是指它们的确是在同一时刻一起运行。并发性是一种软件机制，而并行性则与硬件相关。

在共享资源之中实现并发非常困难，尝试过程将会充满挑战。

角色与进程：
1. 角色是一个独立的虚拟处理单元，拥有本地（且私有）的状态。每个角色有一个信箱，消息出现在信箱中且角色处于空闲状态时，角色被激活并开始处理消息，处理完之后继续处理其他消息，如果信箱是空的，返回休眠状态。
2. 处理过程之中，一个角色可以 创建其他角色，可以向其他认识的角色发送消息，也可以创建一个新的状态。
3. 特点：
	1. 原始数据到最终输出的处理过程不可控。
	2. 系统状态保存在角色本地，消息除了接收方可读取，没有其他途径检查。
	3. 所有消息是单向的，要回应则需要在发送给角色的消息中包含自己的信箱地址。
	4. 角色会将每条消息处理完，一次一条。

### 项目启动之前
需求：
1. 程序员应该帮助客户理解他们真正的需求。
2. 需求是一个过程，要从反馈循环之中逐渐理解客户的需求。
3. 准备需求文档，这是为了团队之中的开发人员知道自己要做的是什么。
4. 不做过于具体的需求，好的需求是抽象的，最简单、最能准确反映业务需求的语句是最好的。
5. 维护一张术语表，项目中所有参与者，包括最终用户和支持员工，都应该用同一张术语表。

务实的入门套件：
1. 版本控制。
2. 无情的持续测试。直到所有的测试都已经运行，编码才算完成。
3. 完全自动化。
